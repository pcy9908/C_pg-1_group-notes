#include <stdio.h>

int main(void)
{
	int length, high, area;
	printf("삼각형 밑변의 길이를 입력하세요.\n");
	scanf_s("%d", &length);

	printf("삼격형 높이의 길이를 입력하세요.\n");
	scanf_s("%d", &high);

	area = length * high / 2;
	printf("삼각형의 넓이는 %d이다.\n", area);

	return 0;
}
==============================================

#include <stdio.h>

int main(void)
{
	unsigned char lastmask = 1; // 2의 0승 위치 : 00000001
	unsigned char firstmask = 128; // 2의 7승 위치 : 10000000
	
	unsigned char input;
	
    printf("값을 입력하시오.\n");
	scanf_s("%c", &input);
	
	printf("입력한 값 %d의 첫 번째 비트는 %d이다.\n", input, input & firstmask);
	
	printf("입력한 값 %d의 마지막 비트는 %d이다.\n", input, input & lastmask);

	return 0;
}
================================================
제출용
Q.
a = 10
b=++a    a = 11, b = 11
b=--a     a = 9, b = 9
b=a++    a = 10, b = 11
b=a--     a = 9, b = 10

Q 예제 4-2 결과의 예측값

a = 21 b = 22 c = 21

a = ++b + ++c 문장 실행
후
a = 45 b = 23 c = 22

a = b++ + c++ 문장 실행 후
a = 45 b = 24 c = 23

예측값과 실행값이 동일함
왜 b++을 하면 c에 21이 될까?
b++은 c에 먼저 기존의 b의 값을 대입을 한다고 생각함.
그래서 c = b++이란 식에서 c = b, b = b+1이라고 순서를 정리함.
c = ++b의 순서는 b = b + 1 에다가 b = c 라고 생각함.  

Q 예제 4-3 예측값
d 의 예측값은 6
e 예측값은 6
g 의 예측값은 2.142857
d, e는 int와 %d로 인해 정수로만 출력되고
g는 f가 float와 %f로 지정되어 있어 소수 6번째 자리까지 출력된다고 생각함.
그래서 g = 15/7을 계산기로 계산하여 알아냄.

Q 혼자해보기 문제 내가 한 코딩
#include <stdio.h>

int main(void)
{
	int length, high, area;
	printf("삼각형 밑변의 길이를 입력하세요.\n");
	scanf_s("%d", &length);

	printf("삼격형 높이의 길이를 입력하세요.\n");
	scanf_s("%d", &high);

	area = length * high / 2;
	printf("삼각형의 넓이는 %d이다.\n", area);

	return 0;
}


Q 예제 4-5

grade = score >= 90; 에서 score는 90보다 크거나 같음. 만약 크거다 같다면 grade는
후에 1을 출력할 것이고 90보다 작다면 0을 출력할 것이다.
그리고 결과를 출력할 때 score가 90을 넘느냐 안넘느냐로 코딩을 짜서 결과를 출력할 줄 알았지만
score의 값을 이용한 grade의 값인 0 또는 1을 이용하여 합격과 불합격을 짜는 것을 확인했다.

Q 예제 4-6 예측
1 && 2 결과는 1
0 && 2 결과는 0
0 || 2 결과는 1
0 || 0 결과는 0
!a 는 1
!b 는 2

Q 예제 4-7 예측
1 && 1 || 0 결과 = 1
1 && 0 || 1 결과 = 1
1 && 0 || 0 결과 = 0

1 && 0 || 0 && 1 결과 = 0

< 1 && 0 > || < 0 && 1> 결과 = 0
==>
1 && 0 = 0 , 0 && 1 = 0
0 || 0 = 0 괄호가 있는 곳 먼저 계산.
-------------------------------------------------
Q. 예제 4-9 예측
만약 25라는 값을 이진수로 바꾸면 11001 이라서 첫 번째 비트와 마지막 비트가 둘 다 1 이겠지만,
코드는 최소 2^0 부터 최대 2^7까지를 표현하기에 11001 앞에 0이 3개 더 붙어서
00011001로 표시가 됨. 그렇기에 첫 번째 비트는 0, 마지막 비트는 1이 될 것으로 예상함.

만약 160이라는 값을 이진수로 바꾸면 1010 0000
lastmark는 0000 0001
firstmark는 1000 0000
lm & 160 = 1
fm & 160 = 0

Q 예제 4-12 예측

x = (y = 5, y + 10) 이라서 y값에 10을 더한 x는 15가 되겠고,
y 값은 5라고 해서 y = 5가 될 것이다. 순서는 y = 5 , y +10 이 된다.
